//===-- M88kRegisterBankInfo.cpp -------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kRegisterBankInfo.h"
#include "MCTargetDesc/M88kMCTargetDesc.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/CodeGen/GlobalISel/LegalizerHelper.h"
#include "llvm/CodeGen/LowLevelType.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/CodeGen/TargetSubtargetInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/ErrorHandling.h"
#include <cassert>

#define GET_TARGET_REGBANK_IMPL
#include "M88kGenRegisterBank.inc"

// This file will be TableGen'ed at some point.
// #include "M88kGenRegisterBankInfo.def"

using namespace llvm;

RegisterBankInfo::PartialMapping M88kGenRegisterBankInfo::PartMappings[]{
    /* StartIdx, Length, RegBank */
    // 0: GPR 32-bit value.
    {0, 32, M88k::GRRegBank},
    // 1: GPR 64-bit value.
    {0, 64, M88k::GRRegBank},
};

// ValueMappings.
RegisterBankInfo::ValueMapping M88kGenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operands instructions (all binary
    // operations should end up with one of those
    // mapping). 1: GR 32-bit value.
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    // 4: 2x GR 32-bit value.
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
};

const RegisterBankInfo::ValueMapping *
M88kGenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx) {
  assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");
  return &ValMappings[First3OpsIdx + 3 * RBIdx];
}

const RegisterBankInfo::ValueMapping *
M88kGenRegisterBankInfo::getCopyMapping(unsigned DstBankID, unsigned SrcBankID,
                                        unsigned Size) {
  assert(DstBankID < M88k::NumRegisterBanks && "Invalid bank ID");
  assert(SrcBankID < M88k::NumRegisterBanks && "Invalid bank ID");

  if (DstBankID == SrcBankID) {
    if (DstBankID == M88k::GRRegBankID) {
      switch (Size) {
      case 32:
        return getValueMapping(PMI_GR32);
      case 64:
        return getValueMapping(PMI_GR64);
      default:
        llvm_unreachable("GR cannot handle that size");
      }
    }
  }
  llvm_unreachable("Unhandled case");
}

M88kRegisterBankInfo::M88kRegisterBankInfo(const TargetRegisterInfo &TRI)
    : M88kGenRegisterBankInfo() {}

const RegisterBank &
M88kRegisterBankInfo::getRegBankFromRegClass(const TargetRegisterClass &RC,
                                             LLT Ty) const {
  switch (RC.getID()) {
  case M88k::GPRRegClassID:
  case M88k::GPR64RegClassID:
    return getRegBank(M88k::GRRegBankID);
  default:
    llvm_unreachable("Unexpected register class");
  }
}

const RegisterBankInfo::InstructionMapping &
M88kRegisterBankInfo::getInstrMapping(const MachineInstr &MI) const {
  const unsigned Opc = MI.getOpcode();

  // Try the default logic for non-generic instructions
  // that are either copies or already have some
  // operands assigned to banks.
  if ((Opc != TargetOpcode::COPY && !isPreISelGenericOpcode(Opc)) ||
      Opc == TargetOpcode::G_PHI) {
    const RegisterBankInfo::InstructionMapping &Mapping =
        getInstrMappingImpl(MI);
    if (Mapping.isValid())
      return Mapping;
  }

  const MachineFunction &MF = *MI.getParent()->getParent();
  const MachineRegisterInfo &MRI = MF.getRegInfo();
  const TargetSubtargetInfo &STI = MF.getSubtarget();
  const TargetRegisterInfo &TRI = *STI.getRegisterInfo();

  unsigned NumOperands = MI.getNumOperands();
  const ValueMapping *OperandsMapping = nullptr;
  unsigned MappingID = DefaultMappingID;

  switch (Opc) {
    // Bitwise ops.
  case TargetOpcode::G_AND:
  case TargetOpcode::G_OR:
  case TargetOpcode::G_XOR:
    OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::G_TRUNC:
    OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::G_SEXT:
  case TargetOpcode::G_ZEXT:
  case TargetOpcode::G_ANYEXT:
    OperandsMapping = getValueMapping(PMI_GR32);
    break;
  case TargetOpcode::COPY: {
    Register DstReg = MI.getOperand(0).getReg();
    Register SrcReg = MI.getOperand(1).getReg();
    // Check if one of the register is not a generic
    // register.
    if ((Register::isPhysicalRegister(DstReg) ||
         !MRI.getType(DstReg).isValid()) ||
        (Register::isPhysicalRegister(SrcReg) ||
         !MRI.getType(SrcReg).isValid())) {
      const RegisterBank *DstRB = getRegBank(DstReg, MRI, TRI);
      const RegisterBank *SrcRB = getRegBank(SrcReg, MRI, TRI);
      if (!DstRB)
        DstRB = SrcRB;
      else if (!SrcRB)
        SrcRB = DstRB;
      // If both RB are null that means both registers
      // are generic. We shouldn't be here.
      assert(DstRB && SrcRB && "Both RegBank were nullptr");
      unsigned Size = getSizeInBits(DstReg, MRI, TRI);
      return getInstructionMapping(
          DefaultMappingID, copyCost(*DstRB, *SrcRB, Size),
          getCopyMapping(DstRB->getID(), SrcRB->getID(), Size),
          // We only care about the mapping of the
          // destination.
          /*NumOperands*/ 1);
    }
    // Both registers are generic, use G_BITCAST.
    llvm_unreachable("Bitcast not handled");
  }
  default:
#if !defined(NDEBUG) || defined(LLVM_ENABLE_DUMP)
    MI.dump();
#endif
    return getInvalidInstructionMapping();
  }

  return getInstructionMapping(MappingID, /*Cost=*/1, OperandsMapping,
                               NumOperands);
}

void M88kRegisterBankInfo::applyMappingImpl(
    const OperandsMapper &OpdMapper) const {
  return applyDefaultMapping(OpdMapper);
}
