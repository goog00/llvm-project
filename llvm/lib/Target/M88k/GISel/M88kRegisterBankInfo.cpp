//===-- M88kRegisterBankInfo.cpp -------------------------------*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
/// \file
/// This file implements the targeting of the RegisterBankInfo class for M88k.
/// \todo This should be generated by TableGen.
//===----------------------------------------------------------------------===//

#include "M88kRegisterBankInfo.h"
#include "MCTargetDesc/M88kMCTargetDesc.h"
#include "llvm/ADT/SmallVector.h"
#include "llvm/CodeGen/GlobalISel/LegalizerHelper.h"
#include "llvm/CodeGen/LowLevelType.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Register.h"
#include "llvm/CodeGen/RegisterBank.h"
#include "llvm/CodeGen/TargetOpcodes.h"
#include "llvm/CodeGen/TargetRegisterInfo.h"
#include "llvm/CodeGen/TargetSubtargetInfo.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/ErrorHandling.h"
#include <cassert>

#define GET_TARGET_REGBANK_IMPL
#include "M88kGenRegisterBank.inc"

// This file will be TableGen'ed at some point.
// #include "M88kGenRegisterBankInfo.def"

using namespace llvm;

RegisterBankInfo::PartialMapping M88kGenRegisterBankInfo::PartMappings[]{
    /*Startidx, Length, RegBank*/
    //0: GPR 32-bit value
    {0, 32, M88k::GRRegBank},
    //1: GPR 64-bit value
    {0, 64, M88k::GRRegBank},
};


// ValueMappings.
RegisterBankInfo::ValueMapping M88kGenRegisterBankInfo::ValMappings[]{
    /* BreakDown, NumBreakDowns */
    // 0: invalid
    {nullptr, 0},
    // 3-operands instructions (all binary
    // operations should end up with one of those
    // mapping). 1: GR 32-bit value.
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR32], 1},
    // 4: 2x GR 32-bit value.
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
    {&M88kGenRegisterBankInfo::PartMappings[PMI_GR64], 1},
};


const RegisterBankInfo::ValueMapping * 
M88kGenRegisterBankInfo::getValueMapping(PartialMappingIdx RBIdx) {
    assert(RBIdx != PartialMappingIdx::PMI_None && "No mapping needed for that");

    return &ValMappings[First30psIdx + 3 * RBIdx];
}    

const RegisterBankInfo::ValueMapping *
M88kGenRegisterBankInfo::getCopyMapping(unsigned DstBankID, unsigned SrcBankID, 
                    unsigned Size) {

        assert(DstBankID < M88k::NumRegisterBanks && "Invalid bank ID");
        assert(SrcBankID < M88k::NumRegisterBanks && "Invalid bank Id");

        if(DstBankID == SrcBankID) {
            if(DstBankID == M88k::GRRegBankID) {
                switch(Size) {
                case 32:
                    return getValueMapping(PMI_GR32);
                case 64:
                    return getValueMapping(PMI_GR64);
                default:
                    llvm_unreachable("GR cannot handle that size");          
                }
            }
        }
        llvm_unreachable("Unhandled case");

}

